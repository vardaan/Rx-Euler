

import rx.Observable;
import rx.functions.Func1;
import rx.math.operators.OperatorMinMax;

import java.math.BigDecimal;
import java.math.BigInteger;

import static java.lang.System.out;


/**
 * Created by HP LAPTOP on 19-05-2015.
 */
public class Problem7 {
    public static void main(String[] args) {


////        By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
////        What is the 10 001st prime number?
//        Observable.range(0, Integer.MAX_VALUE).filter(Problem7::isPrime)
//                .take(10001)
//                .skip(10000)
//                .subscribe(out::println);


//        A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
//                a^2 + b^2 = c^2
//
//        For example, 32 + 42 = 9 + 16 = 25 = 52.
//
////        There exists exactly one Pythagorean triplet for which a + b + c = 1000.
////
//
////        The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
////
////        Find the sum of all the primes below two million.
//        Observable<BigInteger> primeBelowTwoMillion = Observable.range(0, 2000000)
//                .filter(Problem7::isPrime)
//                .map((i) -> new BigInteger(String.valueOf(i)));
//        Observable<BigInteger> bigIntegerObservable = primeBelowTwoMillion.scan(BigInteger::add);
//        bigIntegerObservable.subscribe(out::println);


//        The sequence of triangle numbers is generated by adding the natural numbers.
// So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
//
//        1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
//
//        Let us list the factors of the first seven triangle numbers:
//
//        1: 1
//        3: 1,3
//        6: 1,2,3,6
//        10: 1,2,5,10
//        15: 1,3,5,15
//        21: 1,3,7,21
//        28: 1,2,4,7,14,28
//
//        We can see that 28 is the first triangle number to have over five divisors.
//
//        What is the value of the first triangle number to have over five hundred divisors?
//        Observable.range(1, 100000)
//                .flatMap((i) -> Observable.sumLongs(Observable.range(0, i)
//                                .map((j) -> new Long(String.valueOf(i)))
//                ))
//                .filter((i) -> numDivisors(i) == 20)
//                .takeFirst()
//                .subscribe(out::println);
// the sol is correct but extremely slow
//        Observable.sum(observable).subscribe(out::println);


//        The following iterative sequence is defined for the set of positive integers:
//
//        n → n/2 (n is even)
//        n → 3n + 1 (n is odd)
//
//        Using the rule above and starting with 13, we generate the following sequence:
//        13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1
//
//        It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms.
//    Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.
//
//        Which starting number, under one million, produces the longest chain?
//
//                NOTE: Once the chain starts the terms are allowed to go above one million.
//
//        Observable.range(2, 1000000)
//                .map(new Func1<Integer, Integer>() {
//                    @Override
//                    public Integer call(Integer integer) {
//                        int n = integer;
//                        int count = 0;
//                        while (true) {
//                            if (n % 2 == 0) n = n / 2;
//                            else {
//                                n = (3 * n) + 1;
//                            }
//                            if (n == 1) break;
//                            count++;
//                        }
//                        return count;
//                    }
//                })
//                .scan(Math::max)
//                .last()
//                .subscribe(out::println);
//        observable.take(10).subscribe(out::println);
//        Observable.just(
//                OperatorMinMax.max(observable))
//                .subscribe(out::println);o
//        Observable.just(4, 2, 3, 1).scan(Math::max).subscribe(out::println);


//        215 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.
//
////        What is the sum of the digits of the number 2^1000?
//
//        Observable.just(new BigInteger(String.valueOf(2)))
//                .map((i) -> i.pow(1000))
//                .map(Problem7::sumOfDigits)
//                .subscribe(out::println);

//
////        n! means n × (n − 1) × ... × 3 × 2 × 1
////
////        For example, 10! = 10 × 9 × ... × 3 × 2 × 1 = 3628800,
////                and the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.
////
////        Find the sum of the digits in the number 100!
//            Observable.range(1,100)
//                    .map((i) -> new BigInteger(String.valueOf(i)))
//                    .scan(BigInteger::multiply)
//                    .last()
//                    .map(Problem7::sumOfDigits)
//                    .subscribe(out::println);


//        A perfect number is a number for which the sum of its proper divisors is exactly equal to the number.
// For example, the sum of the proper divisors of 28 would be 1 + 2 + 4 + 7 + 14 = 28, which means that 28 is a perfect number.
//
//        A number n is called deficient if the sum of its proper divisors is less than n and it is called abundant if this sum exceeds n.
//
//                As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16,
// the smallest number that can be written as the sum of two abundant numbers is 24.
// By mathematical analysis, it can be shown that all integers greater than 28123 can be written as the sum of two abundant numbers.
// However, this upper limit cannot be reduced any further by analysis even though
// it is known that the greatest number that cannot be expressed as the sum of two abundant numbers is less than this limit.
//
//                Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers.
        Observable.range(1, 1000)
                .filter(Problem7::isAbundant)
                .subscribe(out::println);


    }


    private static boolean isPrime(int num) {
        if (num < 2) return false;
        if (num == 2) return true;
        if (num % 2 == 0) return false;
        for (int i = 3, p = (int) Math.sqrt(num); i <= p; i++)
            if (num % i == 0) return false;
        return true;
    }

    public static int numDivisors(Long num) {
        int divisors = 0;
        for (int i = 1; i < num; i++) {
            if (num % i == 0) divisors++;
        }
        return divisors;
    }

    public static int sumOfDigits(BigInteger digits) {
        BigInteger ten = BigInteger.valueOf(10);
        int count = 0;
        do {
            count += digits.mod(ten).intValue();
            digits = digits.divide(ten);
        } while (!digits.equals(BigInteger.ZERO));
        return count;
    }

    private static boolean isAbundant(int num) {
        return num == sumOfDivisors(num);
    }

    private static int sumOfDivisors(int n) {
        int maxD = (int) Math.sqrt(n);
        int sum = 1;
        for (int i = 2; i <= maxD; i++) {
            if (n % i == 0) {
                sum += i;
                int d = n / i;
                if (d != i)
                    sum += d;
            }
        }
        return sum;
    }
}